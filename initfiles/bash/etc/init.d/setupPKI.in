#!/bin/bash
################################################################################
#    HPCC SYSTEMS software Copyright (C) 2019 HPCC SystemsÂ®.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
################################################################################

# Phase one of the PKI implementation that uses CA certificate/key pair to generate cert/key for all components.
# CA Server support will be added in Phase two.

###<REPLACE>###

progname=setupPKI

source ${INSTALL_DIR}/etc/init.d/hpcc_common
source ${INSTALL_DIR}/etc/init.d/init-functions
source ${INSTALL_DIR}/etc/init.d/export-path

HPCC_CONFIG=${HPCC_CONFIG:-${CONFIG_DIR}/${ENV_CONF_FILE}}
SECTION=${1:-DEFAULT}
PATH_PREFIX=`cat ${HPCC_CONFIG} | sed -n "/\[${SECTION}\]/,/\[/p" | grep "^home *= *" | sed -e 's/^home *= *//'`
USER_NAME=`cat ${HPCC_CONFIG} | sed -n "/\[${SECTION}\]/,/\[/p" | grep "^user *= *" | sed -e 's/^user *= *//'`
homePath=${PATH_PREFIX}/${USER_NAME}

certPath=${homePath}/certificate
sbin_path="${INSTALL_DIR}/sbin"
envfile="${CONFIG_DIR}/${ENV_XML_FILE}"

OIFS=$IFS
IFS=$'\n'
compArray=($(${sbin_path}/configgen -env ${envfile} -listall | awk 'BEGIN { FS=",";} {print $2;}' | sort | uniq))
IFS=$OIFS

if [ ${#compArray[@]} -eq 0 ]; then
    log "$progname: failure to build COMPS from configgen call"
    echo -e "\033[31merror\033[0m: $progname -> failure to build COMPS from configgen call"
    exit 1
fi

if [ ! -d ${certPath} ]; then
    mkdir -p ${certPath}
fi

domainname=${DOMAINNAME}
if [ "$domainname" = "" ]; then
    domainname=local
fi

subjbase="/C=US/ST=NA/L=Local/O=HPCCSystems/OU=Community"

regenerate=0
if [ "${CAUrl}" == "" ]; then
    CAUrl=${caurl}
    if [ "${CAUrl}" == "" ]; then
        CAUrl=${CAURL}
    fi
fi
if [ "${CAType}" == "" ]; then
    CAType=${catype}
    if [ "${CAType}" == "" ]; then
        CAType=${CATYPE}
    fi
fi
CAUser=""
CAPass=""
#TODO 1. Error handling for cfssl
if [ "${CAUrl}" == "" ] && ([ ! -e ${certPath}/cacert-key.pem ] || [ ! -e ${certPath}/cacert.pem ]); then
    rm -rf ${certPath}/cacert-key.pem ${certPath}/cacert.pem
    subj="${subjbase}/CN=ca.${domainname}"
    openssl req -nodes -newkey rsa:2048 -keyout ${certPath}/cacert-key.pem -out ${certPath}/cacert.csr -subj "${subj}"
    chmod 400 ${certPath}/cacert-key.pem
    openssl x509 -req -days 365 -in ${certPath}/cacert.csr -signkey ${certPath}/cacert-key.pem -sha256 -out ${certPath}/cacert.pem
    rm ${certPath}/cacert.csr
    printf "Generated self-signed CA certificate and privatekey.\n"
    regenerate=1
fi

for i in "" ${compArray[@]} ; do
    compName=""
    if [ "$i" != "" ]; then
        compName=""${i}
    fi
    if [ "${compName}" != "" ]; then
         compNamePrint=${compName}
    else
         compNamePrint="\"\" (default)"
    fi
    if [ ! -d ${certPath}/${compName} ]; then
        mkdir -p ${certPath}/${compName}
    fi

    if [ "${regenerate}" = "1" ] || [ ! -e ${certPath}/${compName}/key.pem ] || [ ! -e ${certPath}/${compName}/certificate.pem ] || [ ! -e ${certPath}/${compName}/public.key.pem ]; then
        if [ "${CAUrl}" != "" ] && [ "${CAType}" != "" ] && [ "${CAType}" != "vault" ] && [ "${CAType}" != "cfssl" ] ; then
            printf "Unsupported CA type ${CAType}\n"
            exit 1
        fi
        if [ "${CAUrl}" != "" ] && [ "${CAPass}" == "" ]; then
            if [ "${CAType}" == "vault" ]; then
                read -s -p "CA Token: " CAPass
            else
                read -p "CA Username: " CAUser
                read -s -p "CA Password: " CAPass
            fi
            printf "\n"
        fi
        if [ "${compName}" != "" ]; then
             cn="${compName}.${domainname}"
        else
             cn="hpcc.${domainname}"
        fi
        if [ "${CAType}" != "vault" ]; then
            compSubject="${subjbase}/CN=${cn}"
            printf "Generating key for ${cn}\n"
            rm -rf ${certPath}/${compName}/key.pem ${certPath}/${compName}/certificate.pem
            openssl req -nodes -newkey rsa:2048 -keyout ${certPath}/${compName}/key.pem -out ${certPath}/${compName}/my.csr -subj "${compSubject}"
            chmod 400 ${certPath}/${compName}/key.pem
            openssl rsa -in ${certPath}/${compName}/key.pem -pubout -out ${certPath}/${compName}/public.key.pem
            printf "PKI keys installed for user %s component %-15s ..." "${USER_NAME}" "${compNamePrint}"
            log_success_msg
        fi
        if [ "${CAUrl}" != "" ]; then
            if [ "${CAType}" == "vault" ]; then
                reqtxt="{\"common_name\":\"${cn}\",\"ou\":\"Community\",\"organization\":\"HPCCSystems\",\"Locality\":\"Local\",\"province\":\"NA\",\"country\":\"US\"}"
                curl -s -X PUT -H "X-Vault-Token: ${CAPass}" -d "${reqtxt}" ${CAUrl}/v1/pki/issue/hpcc > ${certPath}/${compName}/myresp.json
                if [ ! -s ${certPath}/${compName}/myresp.json ]; then
                    printf "Failed to get response from vault CA server\n"
                    exit 1
                fi
                if jq -e 'has("errors")' ${certPath}/${compName}/myresp.json > /dev/null; then
                    printf "Error happened trying to generate certificate from Vault CA: %s\n" "`jq -r '.errors' ${certPath}/${compName}/myresp.json`"
                    exit 1
                fi
                jq -r '.data.certificate' ${certPath}/${compName}/myresp.json > ${certPath}/${compName}/certificate.pem
                jq -r '.data.private_key' ${certPath}/${compName}/myresp.json > ${certPath}/${compName}/key.pem
                if [ "${compName}" == "" ]; then
                    jq -r '.data.issuing_ca' ${certPath}/${compName}/myresp.json > ${certPath}/ca.pem
                fi
                openssl rsa -in ${certPath}/${compName}/key.pem -pubout -out ${certPath}/${compName}/public.key.pem
                #rm -f ${certPath}/${compName}/myresp.json
                if [ ! -e ${certPath}/${compName}/certificate.pem ]; then
                    printf "Failed to generate certificate from Vault CA for component %-15s\n" "${compNamePrint}"
                    exit 1
                else
                    printf "Certificate from Vault CA installed for user %s component %-15s ..." "${USER_NAME}" "${compNamePrint}"
                    log_success_msg
                fi
                if [ ! -e ${certPath}/${compName}/key.pem ]; then
                    printf "Failed to generate private key from Vault CA for component %-15s\n" "${compNamePrint}"
                    exit 1
                else
                    printf "Private key from Vault CA installed for user %s component %-15s ..." "${USER_NAME}" "${compNamePrint}"
                    log_success_msg
                fi
                if [ ! -e ${certPath}/${compName}/public.key.pem ]; then
                    printf "Failed to generate public key from Vault CA for component %-15s\n" "${compNamePrint}"
                    exit 1
                else
                    printf "Public key from Vault CA installed for user %s component %-15s ..." "${USER_NAME}" "${compNamePrint}"
                    log_success_msg
                fi
            else
                if [ "${compName}" == "" ]; then
                    curl -s -H "Content-Type: application/json" -X POST -d "{\"label\":\"\",\"profile\":\"\"}" ${CAUrl}/api/v1/cfssl/info > ${certPath}/inforesp.json
                    jq -r '.result.certificate' ${certPath}/inforesp.json > ${certPath}/ca.pem
                    #rm -f ${certPath}/inforesp.json
                fi
                csrtxt=$(sed -e ':a' -e 'N;$!ba' -e 's/\n/\\n/g' ${certPath}/${compName}/my.csr)
                now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
                oneyear=$(date -u --date '+ 1 year' +"%Y-%m-%dT%H:%M:%SZ")
                reqtxt="{\"hosts\":[\"${cn}\"],\"certificate_request\":\"${csrtxt}\",\"profile\":\"${CAUser}\",\"crl_override\":\"\",\"label\":\"default\",\"NotBefore\":\"${now}\",\"NotAfter\":\"${oneyear}\",\"ReturnPrecert\":false,\"metadata\":null}"
                csrtoken=$(echo ${reqtxt} | openssl sha256 -hmac ${CAPass} -binary | openssl base64)
                reqbase64=$(echo ${reqtxt} | openssl base64 -e -A)
                csrreq="{\"timestamp\":$(date +%s),\"token\":\"${csrtoken}\",\"request\":\"${reqbase64}\"}"
                echo ${csrreq} | curl -s -H "Content-Type: application/json" -X POST --data-binary @- ${CAUrl}/api/v1/cfssl/authsign > ${certPath}/${compName}/myresp.json
                if [ ! -s ${certPath}/${compName}/myresp.json ]; then
                    printf "Failed to get response from remote CA server\n"
                    exit 1
                fi
                if jq -e ".success!=true" ${certPath}/${compName}/myresp.json > /dev/null; then
                    printf "Error happened trying to generate certificate from remote CA: %s\n" "`jq -r '.errors' ${certPath}/${compName}/myresp.json`"
                    exit 1
                fi
                jq -r '.result.certificate' ${certPath}/${compName}/myresp.json > ${certPath}/${compName}/certificate.pem
                #rm -f ${certPath}/${compName}/my.csr ${certPath}/${compName}/myresp.json
                if [ ! -e ${certPath}/${compName}/certificate.pem ]; then
                    printf "Failed to generate certificate from remote CA for component %-15s\n" "${compNamePrint}"
                    exit 1
                else
                    printf "Certificate from remote CA installed for user %s component %-15s ..." "${USER_NAME}" "${compNamePrint}"
                    log_success_msg
                fi
            fi
        else
            openssl x509 -req -days 365 -in ${certPath}/${compName}/my.csr -CA ${certPath}/cacert.pem -CAkey ${certPath}/cacert-key.pem -sha256 -CAcreateserial -CAserial ca.seq -out ${certPath}/${compName}/certificate.pem
            rm ${certPath}/${compName}/my.csr
            if [ ! -e ${certPath}/${compName}/certificate.pem ]; then
                printf "Failed to generate certificate for component %-15s\n" "${compNamePrint}"
                exit 1
            else
                printf "Certificate from local CA installed for user %s component %-15s ..." "${USER_NAME}" "${compNamePrint}"
                log_success_msg
            fi
        fi
    else
        printf "PKI key and certificate are already installed for user %s component %-15s ..." "${USER_NAME}" "${compNamePrint}"
        log_success_msg
    fi
done

chown -R ${USER_NAME}:${USER_NAME} ${certPath}

if [ ! -e ${homePath}/.ssh/id_rsa ]; then
    cp ${certPath}/key.pem ${homePath}/.ssh/id_rsa
    ssh-keygen -y -f ${certPath}/key.pem > ${homePath}/.ssh/id_rsa.pub
    cat ${homePath}/.ssh/id_rsa.pub >> ${homePath}/.ssh/authorized_keys
    printf "ssh keys installed for user %s ..." "${USER_NAME}"
    log_success_msg
else
    printf "ssh keys already installed for %s ..." "${USER_NAME}"
    log_success_msg
fi

exit 0
